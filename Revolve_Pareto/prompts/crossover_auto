You are given two policy-as-code controllers for autonomous driving.
Each policy is implemented as a Python class `Policy` with a `compute_action(self, obs, path)` method that outputs `(steering, throttle, brake)`.  

<Policy>  
Both policies have fitness scores that reflect the agent’s performance, averaged over many test episodes. Higher scores indicate superior behavior.  
We also track the following metrics for each policy (higher is better unless noted):  
- **progress**: fraction of the reference path completed [0–1].  
- **lane_score**: path-following accuracy (higher = closer to lane center).  
- **smooth_score**: steering smoothness (higher = less oscillation).  
- **eff_score**: efficiency of completion (higher = finished quickly and smoothly).  
- **collision**: True if the agent collided.  
- **num_red_violations**: number of traffic light violations.  
- **collision_pen / tl_pen / stationary_pen**: penalties applied if collisions, red-light violations, or long idle times occurred (0.50, 0.40, 0.50).  
- **total_fitness**: the final fitness score for the episode (0 = worst, 1 = best). Combines all metrics and penalties.  
- **end_reason**: why the episode ended (`"loop_complete"`, `"collision"`, or `"timeout"`).  
- **collided_with_ids**: list of CARLA actor IDs/types the agent collided with (empty if no collision).  
- **episodes**: number of evaluation episodes run for this policy.  
- **fitness**: average `total_fitness` over all episodes, used as the overall score for the policy.  

Penalties applied are fixed values:  
- collision_pen = 0.50  
- tl_pen = 0.40  
- stationary_pen = 0.50  

metrics from the two candidate policies:  
<Metrics>  
(Parent scores: "fitness" == ΔHV over {lane, progress, smoothness, safety}.
Safety per episode: safe_t = 1 if collision_t==0 AND num_red_violations_t==0 else 0;
dataset safety = mean_t safe_t.)


**Your task:**  
Create a new `Policy` by performing crossover between the two given policies.  
- Identify strong components from each policy based on the metrics.  
- Combine them into a single new policy class.  
- Preserve as much working logic as possible, replacing weaker parts with stronger ones.  
- The crossover should alter only a few coherent modules, not rewrite the entire policy.  

**Output requirement:**  
Output exactly one fenced Python code block (` ```python ... ``` `) containing the complete `Policy` class with its `compute_action(self, obs, path)` method. Return `(steering, throttle, brake)` as floats. Do not include explanations inside the code block.  
```python
class Policy:
    def __init__(...):
        ...
    def compute_action(self, obs, path):
        return (steering, throttle, brake)
```

**Tips:**  
- Combine strong elements (e.g., steering from Policy A, pedestrian handling from Policy B).  
- Select coherent modules directly from either parent (e.g., steering from Policy A, pedestrian handling from Policy B).  
- Do not try to improve weaknesses or invent new logic — simply recombine existing parts.  
- Make minimal changes required only for consistency of the merged code.  
- Use only the fields available in `obs`.  
- Do not introduce new input fields or external dependencies.  
